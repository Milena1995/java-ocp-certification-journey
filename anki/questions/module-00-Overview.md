## Question

Which Java ecosystem is primarily intended for traditional enterprise applications (servers, transactions, security)?<br><br>

Please select 1 option<br><br>

A) Java SE<br>
B) Java ME<br>
C) Java EE<br>
D) Java Card

## Réponse

<strong>Réponse correcte :</strong> C)<br><br>

<strong>Java EE</strong> (now <strong>Jakarta EE</strong>) is designed for enterprise applications, with:<br>
• Transaction management<br>
• Persistence<br>
• Security<br><br>

<strong>Java SE</strong>: standard language base.<br>
<strong>Java ME</strong>: embedded systems.<br>
<strong>Java Card</strong>: smart cards.

## Question

Which statement best describes Java's "Write Once Run Anywhere" principle?<br><br>

Please select 1 option<br><br>

A) Java source code can run directly on any processor<br>
B) The javac compiler produces universal machine code<br>
C) The JVM translates Java code into machine language before compilation<br>
D) Java bytecode can run on any machine with a JVM

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

The "Write Once Run Anywhere" principle means that the <strong>bytecode</strong> generated by compilation can run on any platform with a <strong>JVM</strong>.<br><br>

<strong>A) is incorrect:</strong> Source code must first be compiled into bytecode.<br>
<strong>B) is incorrect:</strong> The compiler produces bytecode, not machine code.<br>
<strong>C) is incorrect:</strong> The JVM translates bytecode during execution, not before compilation.

## Question

What is the difference between a class and an object in Java?<br><br>

Please select 1 option<br><br>

A) A class is a compiled object<br>
B) An object is a class that has the main() method<br>
C) There is no difference, they are two terms for the same thing<br>
D) A class is a blueprint, an object is an instance created in memory

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

A <strong>class</strong> is a <strong>blueprint (template)</strong> that defines attributes and methods. An <strong>object</strong> is an <strong>instance</strong> of that class, created in memory at runtime.<br><br>

Example:<br>
<strong>Class Car</strong> = the toy blueprint<br>
<strong>Car myCar = new Car()</strong> = the actual toy in hand<br><br>

<strong>A) is incorrect:</strong> Compilation produces bytecode, not objects.<br>
<strong>B) is incorrect:</strong> The main() method has nothing to do with the object/class definition.<br>
<strong>C) is incorrect:</strong> These are two distinct and fundamental concepts.

## Question

What does the JDK contain?<br><br>

Please select all that apply<br><br>

A) The javac compiler<br>
B) The JVM<br>
C) Development tools<br>
D) A source code editor

## Réponse

<strong>Réponse correcte :</strong> A), B), C)<br><br>

The <strong>JDK (Java Development Kit)</strong> contains:<br>
• The <strong>javac</strong> compiler<br>
• The <strong>JVM</strong><br>
• <strong>Development tools</strong> (debugger, javadoc, etc.)<br><br>

<strong>D) is incorrect:</strong> The JDK does not contain a code editor (IDE). You must use an external tool like IntelliJ, Eclipse, or VS Code.

## Question

What does the JRE contain?<br><br>

Please select 1 option<br><br>

A) Only the JVM<br>
B) The JVM and the javac compiler<br>
C) The source code of standard Java libraries<br>
D) The JVM and Java libraries compiled into bytecode

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

The <strong>JRE (Java Runtime Environment)</strong> contains:<br>
• The <strong>JVM</strong><br>
• <strong>Java libraries already compiled into bytecode</strong> (System, String, Math, etc.)<br><br>

<strong>A) is incorrect:</strong> The JRE also contains standard libraries.<br>
<strong>B) is incorrect:</strong> The javac compiler is in the JDK, not the JRE.<br>
<strong>C) is incorrect:</strong> Libraries are in bytecode (.class), not source code.

## Question

What is the JVM?<br><br>

Please select 1 option<br><br>

A) A compiler that transforms Java into machine code<br>
B) A programming language<br>
C) A physical processor optimized for Java<br>
D) A software program that executes Java bytecode

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

The <strong>JVM (Java Virtual Machine)</strong> is a <strong>software program</strong> that executes Java bytecode. It's a program like Chrome, VS Code, or Spotify.<br><br>

The JVM:<br>
• Reads bytecode<br>
• Translates it into instructions for the processor<br>
• Manages memory<br><br>

<strong>A) is incorrect:</strong> javac compiles, the JVM executes.<br>
<strong>B) is incorrect:</strong> Java is the language, the JVM is the execution environment.<br>
<strong>C) is incorrect:</strong> It's software, not hardware.

## Question

When is a program said to be at "runtime"?<br><br>

Please select 1 option<br><br>

A) During source code compilation<br>
B) During code writing in the IDE<br>
C) During .class file creation<br>
D) During program execution by the JVM

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

<strong>Runtime</strong> is the <strong>execution</strong> phase of the program, after startup. At runtime:<br>
• Objects are created in memory<br>
• Methods are called<br>
• <strong>RuntimeException</strong> errors can occur<br><br>

Opposite of <strong>compile-time</strong> (compilation moment).<br><br>

<strong>A) and C) are incorrect:</strong> This is compile-time.<br>
<strong>B) is incorrect:</strong> Code writing precedes compilation and execution.

## Question

Which statement is correct regarding errors in Java?<br><br>

Please select 1 option<br><br>

A) NullPointerException occurs at compile-time<br>
B) Syntax errors occur at runtime<br>
C) All errors are detected before execution<br>
D) Type errors are detected at compile-time

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

At <strong>compile-time</strong>:<br>
• Syntax errors<br>
• Type checking<br>
• No objects in memory<br><br>

At <strong>runtime</strong>:<br>
• <strong>NullPointerException</strong><br>
• Objects in memory<br>
• Actual values<br><br>

<strong>A) is incorrect:</strong> NullPointerException is a runtime error.<br>
<strong>B) is incorrect:</strong> Syntax errors are detected at compile-time.<br>
<strong>C) is incorrect:</strong> Many errors only appear at runtime.

## Question

At what point does the processor intervene in executing a Java program?<br><br>

Please select 1 option<br><br>

A) During source code writing<br>
B) During Java to bytecode compilation<br>
C) The processor directly executes Java bytecode<br>
D) Only when the JVM executes the bytecode

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

The processor intervenes <strong>only when the JVM is executing the program</strong>.<br><br>

Complete flow:<br>
• Code writing → <strong>no processor</strong><br>
• Compilation (javac) → processor executes javac, <strong>not your program</strong><br>
• Execution (java) → <strong>JVM starts</strong> → <strong>JVM gives work to the processor</strong><br><br>

Mental image:<br>
Your Java program → JVM → Processor<br><br>

<strong>C) is incorrect:</strong> The processor never directly executes bytecode, it executes the JVM.

## Question

What is Java's organizational structure from smallest to largest?<br><br>

Please select 1 option<br><br>

A) Module → Package → Class<br>
B) Package → Class → Module<br>
C) Class → Module → Package<br>
D) Class → Package → Module

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

Java hierarchical structure:<br>
• <strong>Class</strong>: basic unit (blueprint)<br>
• <strong>Package</strong>: group of classes<br>
• <strong>Module</strong>: group of packages<br><br>

Analogy:<br>
Class = file<br>
Package = folder<br>
Module = project<br><br>

<strong>A), B), C) are incorrect:</strong> The order is reversed or mixed up.

## Question

Why is Eclipse Temurin recommended for learning Java 21?<br><br>

Please select 1 option<br><br>

A) It's the only JDK compatible with Java 21<br>
B) It contains exclusive features absent from other JDKs<br>
C) It allows native compilation unlike others<br>
D) It's an OpenJDK with long-term support, stable and free

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

<strong>Eclipse Temurin</strong> is recommended because:<br>
• Based on <strong>OpenJDK</strong><br>
• <strong>Long-term support</strong><br>
• Widely used in enterprise<br>
• <strong>Stable and free</strong><br>
• Default choice for learning<br><br>

<strong>A) is incorrect:</strong> Several JDKs are compatible with Java 21.<br>
<strong>B) is incorrect:</strong> All JDKs respect the same Java specification.<br>
<strong>C) is incorrect:</strong> GraalVM offers native compilation.

## Question

What is JAVA_HOME?<br><br>

Please select 1 option<br><br>

A) The installation directory of all Java programs<br>
B) A system PATH configuration file<br>
C) The storage folder for compiled .class files<br>
D) An environment variable containing the path to the active JDK

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

<strong>JAVA_HOME</strong> is an <strong>environment variable</strong> that contains the path to the active JDK.<br><br>

Example:<br>
/Library/Java/JavaVirtualMachines/temurin-21.jdk/Contents/Home<br><br>

Importance:<br>
• Maven, Gradle, IDEs use it<br>
• Source of truth for tools<br>
• Avoids version conflicts<br><br>

<strong>A) is incorrect:</strong> It's the path to ONE specific JDK.<br>
<strong>B) is incorrect:</strong> It's a variable, not a file.<br>
<strong>C) is incorrect:</strong> It's not a compilation output folder.

## Question

What does the command `/usr/libexec/java_home -v 21` do on macOS?<br><br>

Please select 1 option<br><br>

A) It installs Java 21<br>
B) It compiles a Java program with version 21<br>
C) It removes all Java versions except 21<br>
D) It finds and returns the exact path of the installed JDK 21

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

This command:<br>
• <strong>Finds</strong> JDK 21 among installed JDKs<br>
• <strong>Returns the exact path</strong> of the JDK<br>
• Avoids manual errors<br>
• It's the <strong>official Apple method</strong><br><br>

Typical usage:<br>
export JAVA_HOME=$(/usr/libexec/java_home -v 21)<br><br>

<strong>A) is incorrect:</strong> It only finds, doesn't install.<br>
<strong>B) is incorrect:</strong> It's not a compilation command.<br>
<strong>C) is incorrect:</strong> It doesn't modify installations.

## Question

Why do we modify PATH with `export PATH=$JAVA_HOME/bin:$PATH`?<br><br>

Please select 1 option<br><br>

A) To install Java in a new directory<br>
B) To compile faster<br>
C) To allow program execution without JVM<br>
D) So the java and javac commands use the Java from JAVA_HOME

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

Modifying PATH with <strong>$JAVA_HOME/bin</strong> ensures that:<br>
• The <strong>java</strong> and <strong>javac</strong> commands use the Java from JAVA_HOME<br>
• Not another Java installed elsewhere<br>
• Total consistency<br><br>

Structure:<br>
JDK → JAVA_HOME (central truth) → PATH → java/javac<br><br>

<strong>A) is incorrect:</strong> PATH doesn't modify the installation.<br>
<strong>B) is incorrect:</strong> It doesn't affect performance.<br>
<strong>C) is incorrect:</strong> The JVM remains necessary to execute Java.

## Question

Which statement is true regarding different JDK distributions?<br><br>

Please select 1 option<br><br>

A) Each JDK implements a different Java dialect<br>
B) Oracle JDK is the only JDK certified for production<br>
C) GraalVM is recommended for starting with Java<br>
D) All JDKs respect the same standard Java specification

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

Java is a <strong>standardized language</strong>. All JDKs must respect the <strong>Java spec</strong>, so:<br>
• Same behavior<br>
• Same API<br>
• Guaranteed compatibility<br><br>

Common distributions:<br>
• Eclipse Temurin (recommended)<br>
• Oracle JDK<br>
• Amazon Corretto<br>
• Azul Zulu<br><br>

<strong>A) is incorrect:</strong> All implement the same Java.<br>
<strong>B) is incorrect:</strong> Several JDKs are certified.<br>
<strong>C) is incorrect:</strong> GraalVM is not for beginners.

## Question

What is the entry point of an executable Java program?<br><br>

Please select 1 option<br><br>

A) The first class in the file<br>
B) The constructor of the main class<br>
C) The public void run() method<br>
D) The public static void main(String[] args) method

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

The entry point of a Java program is the method:<br>
<strong>public static void main(String[] args)</strong><br><br>

Mandatory characteristics:<br>
• <strong>public</strong>: accessible from everywhere<br>
• <strong>static</strong>: no need to instantiate the class<br>
• <strong>void</strong>: returns nothing<br>
• <strong>main</strong>: exact name required<br>
• <strong>String[] args</strong>: command line parameters<br><br>

<strong>A) is incorrect:</strong> Class order doesn't matter.<br>
<strong>B) is incorrect:</strong> The constructor is not the entry point.<br>
<strong>C) is incorrect:</strong> This is for Runnable/Thread, not the main entry point.

## Question

What file extension is produced by the javac compiler?<br><br>

Please select 1 option<br><br>

A) .java<br>
B) .jar<br>
C) .exe<br>
D) .class

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

The <strong>javac</strong> compiler compiles source code (.java) into <strong>bytecode</strong> (.class).<br><br>

Compilation flow:<br>
Main.java → javac → Main.class<br><br>

The <strong>.class</strong> file contains Java bytecode that can be executed by any JVM.<br><br>

<strong>A) is incorrect:</strong> .java is the source file, not the compilation output.<br>
<strong>B) is incorrect:</strong> .jar is an archive containing multiple .class files, created with jar.<br>
<strong>C) is incorrect:</strong> Java doesn't produce native .exe files.

## Question

Why do we put the JAVA_HOME configuration in the .zshrc (or .bashrc) file?<br><br>

Please select 1 option<br><br>

A) To automatically compile Java code<br>
B) To install Java at system startup<br>
C) To share JAVA_HOME with other users<br>
D) So JAVA_HOME is automatically defined each time the terminal opens

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

Putting the configuration in <strong>.zshrc</strong> (or .bashrc) allows:<br>
• The shell reads this file at startup<br>
• <strong>JAVA_HOME</strong> is automatically defined<br>
• <strong>Persistent</strong> configuration for each terminal<br>
• No need to manually redefine<br><br>

Example:<br>
export JAVA_HOME=$(/usr/libexec/java_home -v 21)<br>
export PATH=$JAVA_HOME/bin:$PATH<br><br>

<strong>A) is incorrect:</strong> It's not for automatic compilation.<br>
<strong>B) is incorrect:</strong> It doesn't perform installation.<br>
<strong>C) is incorrect:</strong> It's user-specific, not shared.

## Question

When a Java class declares a package, from where should the javac and java commands be launched?<br><br>

Please select 1 option<br><br>

A) From any project folder<br>
B) From the folder that directly contains the .java file<br>
C) From the parent folder of the declared package<br>
D) From the classpath root, the folder that contains the packages

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

<strong>Fundamental rule:</strong> With packages, we always compile and execute <strong>from the folder that represents the classpath root</strong>, i.e., the folder that contains the packages.<br><br>

Never from a package subfolder.<br><br>

<strong>A) is incorrect:</strong> The position must be precisely the classpath root.<br>
<strong>B) is incorrect:</strong> Placing yourself in the package itself causes resolution errors.<br>
<strong>C) is incorrect:</strong> This is too vague, you must be exactly at the root.

## Question

Given the declaration: `package primitive_types.foundation_ex_4_1;`<br>
What file path does Java expect to find the compiled class?<br><br>

Please select 1 option<br><br>

A) primitive_types/Class.class<br>
B) foundation_ex_4_1/Class.class<br>
C) Class.class<br>
D) primitive_types/foundation_ex_4_1/Class.class

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

The <strong>package is a logical path</strong>. The declaration:<br>
package primitive_types.foundation_ex_4_1;<br><br>

Means Java expects to find the class in:<br>
<strong>primitive_types/foundation_ex_4_1/Class.class</strong><br><br>

The package is not just a name, it's a <strong>mandatory directory structure</strong>.<br><br>

<strong>A) and B) are incorrect:</strong> The complete path must match the package exactly.<br>
<strong>C) is incorrect:</strong> Without a package, the class would be in the default package.

## Question

What is the classpath?<br><br>

Please select 1 option<br><br>

A) The absolute path to the installed JDK<br>
B) The folder containing .java source files<br>
C) A mandatory environment variable for compiling<br>
D) The starting point from which Java searches for classes

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

The <strong>classpath</strong> is the <strong>starting point</strong> from which Java searches for classes.<br><br>

By default:<br>
• javac and java use the current folder (.) as classpath<br>
• The current folder MUST be the package root<br><br>

<strong>A) is incorrect:</strong> That's JAVA_HOME.<br>
<strong>B) is incorrect:</strong> The classpath can contain .class files, not just .java.<br>
<strong>C) is incorrect:</strong> It's optional, there's a default value (.).

## Question

Given the following structure:<br>
```
src/
└── primitive_types/
    └── foundation_ex_4_1/
        ├── Customer.java
        └── ShopApp.java
```
<br>
From which folder should you compile?<br><br>

Please select 1 option<br><br>

A) From primitive_types/<br>
B) From foundation_ex_4_1/<br>
C) From anywhere if you specify the full path<br>
D) From src/

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

You must compile <strong>from src/</strong> which is the <strong>classpath root</strong>, the folder that contains the packages.<br><br>

Correct command:<br>
javac primitive_types/foundation_ex_4_1/*.java<br><br>

Or:<br>
javac primitive_types/foundation_ex_4_1/ShopApp.java<br><br>

<strong>A) and B) are incorrect:</strong> Placing yourself in a sub-package causes class resolution errors.<br>
<strong>C) is incorrect:</strong> The classpath must be correctly positioned.

## Question

With the same structure, which command correctly executes ShopApp from src/?<br><br>

Please select 1 option<br><br>

A) java ShopApp<br>
B) java primitive_types/foundation_ex_4_1/ShopApp<br>
C) java foundation_ex_4_1.ShopApp<br>
D) java primitive_types.foundation_ex_4_1.ShopApp

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

To execute, we use the <strong>fully qualified name</strong> with <strong>dots</strong>:<br>
java primitive_types.foundation_ex_4_1.ShopApp<br><br>

Always from <strong>src/</strong> (classpath root).<br><br>

<strong>A) is incorrect:</strong> Java doesn't find the class without the full package.<br>
<strong>B) is incorrect:</strong> We use dots (.), not slashes (/).<br>
<strong>C) is incorrect:</strong> The complete package is necessary.

## Question

What happens if we place ourselves in `foundation_ex_4_1/` and compile with `javac ShopApp.java`?<br><br>

Please select 1 option<br><br>

A) Compilation succeeds normally<br>
B) Compilation succeeds but execution fails<br>
C) Java automatically corrects the classpath<br>
D) Error: cannot find symbol class Customer

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

<strong>Error:</strong> cannot find symbol class Customer<br><br>

<strong>Why?</strong><br>
Because Java thinks the classpath = foundation_ex_4_1<br><br>

It then searches for:<br>
foundation_ex_4_1/primitive_types/foundation_ex_4_1/ShopApp.class<br><br>

This path doesn't exist, so Java doesn't find Customer.<br><br>

<strong>A) and B) are incorrect:</strong> Compilation fails immediately.<br>
<strong>C) is incorrect:</strong> Java doesn't guess or correct the classpath.

## Question

How does Java search for classes in packages?<br><br>

Please select 1 option<br><br>

A) It recursively traverses all project folders<br>
B) It automatically goes up the tree if necessary<br>
C) It uses artificial intelligence to guess the location<br>
D) It starts only from the classpath and follows exactly the declared package

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

<strong>Key Oracle point:</strong><br>
Java doesn't "go up" or "go down" in packages automatically.<br>
It starts <strong>only from the classpath</strong>.<br><br>

• Java doesn't guess<br>
• Java doesn't correct<br>
• Java doesn't freely traverse the tree<br><br>

It follows <strong>exactly</strong> the path indicated by the package.<br><br>

<strong>A), B), C) are incorrect:</strong> Java follows a strict and predictable rule.

## Question

What is the main difference between an IDE and the Oracle exam regarding the classpath?<br><br>

Please select 1 option<br><br>

A) IDEs don't use classpath<br>
B) The exam prohibits using the classpath<br>
C) There is no difference<br>
D) The IDE manages the classpath automatically, the exam requires manual reasoning

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

<strong>IntelliJ / IDE:</strong><br>
• Manages the classpath automatically<br>
• Hides complexity<br>
• Can give the illusion that "everything works"<br><br>

<strong>Oracle exam:</strong><br>
• Manual reasoning required<br>
• You must know where you position yourself<br>
• You must know the classpath<br>
• You must understand how Java searches for classes<br><br>

<strong>A), B), C) are incorrect:</strong> Both use the classpath differently.

## Question

Which command correctly compiles all Java files in a package from the root?<br><br>

Please select 1 option<br><br>

A) javac *.java<br>
B) javac primitive_types/*.java<br>
C) javac -r primitive_types/<br>
D) javac primitive_types/foundation_ex_4_1/*.java

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

From the root (src/), the correct command is:<br>
<strong>javac primitive_types/foundation_ex_4_1/*.java</strong><br><br>

This compiles all .java files in this specific package.<br><br>

<strong>A) is incorrect:</strong> Only compiles files in the current folder, not in packages.<br>
<strong>B) is incorrect:</strong> Doesn't descend into sub-packages.<br>
<strong>C) is incorrect:</strong> The -r option doesn't exist for javac.

## Question

If ShopApp.java uses the Customer.java class from the same package, must Customer be specified in the javac command?<br><br>

Please select 1 option<br><br>

A) Yes, you must always compile all dependencies manually<br>
B) Only if Customer is in another package<br>
C) It depends on the Java version used<br>
D) No, javac automatically finds Customer if compiling from the root

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

If we compile correctly from the root:<br>
javac primitive_types/foundation_ex_4_1/ShopApp.java<br><br>

<strong>Java automatically finds Customer</strong> because:<br>
• Same package<br>
• Classpath correctly positioned<br>
• javac automatically resolves dependencies in the same package<br><br>

<strong>A) is incorrect:</strong> javac is intelligent for local dependencies.<br>
<strong>B) is incorrect:</strong> It's true in the same package too.<br>
<strong>C) is incorrect:</strong> This behavior has been standard since Java 1.0.

## Question

Which symbol is used to separate packages when executing a class?<br><br>

Please select 1 option<br><br>

A) The slash (/) like in file paths<br>
B) The backslash (\) like in Windows<br>
C) The dash (-) as a logical separator<br>
D) The dot (.) like in the fully qualified name

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

To execute a class, we use the <strong>fully qualified name</strong> with <strong>dots (.)</strong>:<br><br>

java com.example.Main<br><br>

<strong>Attention to the trap:</strong><br>
• Compilation: javac com/example/Main.java (slash)<br>
• Execution: java com.example.Main (dots)<br><br>

<strong>A) is incorrect:</strong> Slashes are for javac, not java.<br>
<strong>B) and C) are incorrect:</strong> These symbols are never used for packages.

## Question

What happens if the physical folder doesn't match exactly the declared package?<br><br>

Please select 1 option<br><br>

A) Java automatically corrects the path<br>
B) The IDE displays a warning but it compiles<br>
C) It works if you specify the -classpath option<br>
D) Compilation fails with a package error

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

If the folder structure doesn't match <strong>exactly</strong> the declared package, compilation fails.<br><br>

Example error:<br>
<strong>class X is public, should be declared in a file named X.java</strong><br>
or<br>
<strong>package declaration does not match directory structure</strong><br><br>

Java requires a <strong>strict match</strong> between:<br>
• The package declaration<br>
• The directory structure<br><br>

<strong>A), B), C) are incorrect:</strong> No correction or workaround possible.

## Question

If we have: `package com.oracle.exam;` and compile from the parent folder of com/, what does Java search for?<br><br>

Please select 1 option<br><br>

A) exam/Class.class<br>
B) oracle/exam/Class.class<br>
C) ../com/oracle/exam/Class.class<br>
D) com/oracle/exam/Class.class

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

Java <strong>always</strong> searches for the complete path corresponding to the package from the classpath.<br><br>

With package com.oracle.exam;<br>
Java searches for: <strong>com/oracle/exam/Class.class</strong><br><br>

If you're in the right folder (the one containing com/), it works.<br>
Otherwise, resolution error.<br><br>

<strong>A) and B) are incorrect:</strong> The complete package must be respected.<br>
<strong>C) is incorrect:</strong> Java doesn't use relative paths like ../

## Question

Why does the "cannot find symbol" error often appear with packages?<br><br>

Please select 1 option<br><br>

A) The .java file doesn't exist<br>
B) The class doesn't have a main() method<br>
C) The JDK isn't installed correctly<br>
D) We're compiling from the wrong folder, Java can't find the class in the classpath

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

<strong>cannot find symbol</strong> with packages generally indicates we're compiling from the <strong>wrong folder</strong>.<br><br>

Java searches for the class starting from the classpath, but:<br>
• The classpath is poorly positioned<br>
• The package structure doesn't match<br>
• We're not at the package root<br><br>

<strong>Solution:</strong> Position yourself at the classpath root and recompile.<br><br>

<strong>A), B), C) are incorrect:</strong> These errors give different messages.

## Question

Which statements about the default package are correct?<br><br>

Please select all that apply<br><br>

A) All classes must declare a package<br>
B) Classes without package declaration belong to the default package<br>
C) The default package is called "default"<br>
D) You cannot import classes from the default package into other packages

## Réponse

<strong>Réponse correcte :</strong> B), D)<br><br>

Classes <strong>without package declaration</strong> belong to the <strong>default package (unnamed package)</strong>.<br><br>

Characteristics:<br>
• No package name<br>
• Classes are directly at the root<br>
• <strong>Limited: you cannot import these classes into other packages</strong><br>
• <strong>Discouraged in production</strong><br><br>

<strong>A) is incorrect:</strong> The package is optional.<br>
<strong>C) is incorrect:</strong> It has no name, that's why we call it "unnamed".

## Question

Given two classes: com.app.Main and com.util.Helper.<br>
Can Main use Helper without an import?<br><br>

Please select 1 option<br><br>

A) Yes, because they both start with com<br>
B) Yes, if they are in the same file<br>
C) Yes, if Helper is public<br>
D) No, because they are in different packages

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

<strong>No</strong>, Main must import Helper because they are in <strong>different packages</strong>:<br>
• com.app ≠ com.util<br><br>

You must add:<br>
import com.util.Helper;<br><br>

<strong>Packages must match exactly.</strong> Sharing a common prefix (com) is not enough.<br><br>

<strong>A) is incorrect:</strong> The complete package must match.<br>
<strong>B) is incorrect:</strong> You cannot have two public classes in the same file.<br>
<strong>C) is incorrect:</strong> Public doesn't exempt from import.

## Question

Which commands explicitly specify the classpath to a folder named "bin"?<br><br>

Please select all that apply<br><br>

A) javac -classpath bin Main.java<br>
B) javac -cp bin Main.java<br>
C) javac -path bin Main.java<br>
D) javac --class-path bin Main.java

## Réponse

<strong>Réponse correcte :</strong> A), B)<br><br>

Both forms are correct and equivalent:<br>
• <strong>javac -classpath bin Main.java</strong><br>
• <strong>javac -cp bin Main.java</strong><br><br>

<strong>-cp</strong> is just an abbreviation of <strong>-classpath</strong>.<br><br>

This tells javac that the classpath is the "bin" folder instead of the current folder (.).<br><br>

<strong>C) and D) are incorrect:</strong> These options don't exist.

## Question

Given this structure:<br>
```
project/
├── src/
│   └── com/app/Main.java
└── bin/
```
<br>
How do you compile Main.java so the .class goes into bin/?<br><br>

Please select all that apply<br><br>

A) javac src/com/app/Main.java -d bin<br>
B) javac -d bin src/com/app/Main.java<br>
C) javac src/com/app/Main.java > bin<br>
D) javac --destination bin src/com/app/Main.java

## Réponse

<strong>Réponse correcte :</strong> A), B)<br><br>

Both commands are correct:<br>
• javac src/com/app/Main.java -d bin<br>
• javac -d bin src/com/app/Main.java<br><br>

The <strong>-d</strong> option specifies the <strong>destination folder</strong> for .class files.<br><br>

Java will automatically create: bin/com/app/Main.class<br><br>

<strong>C) is incorrect:</strong> The > symbol doesn't work for javac.<br>
<strong>D) is incorrect:</strong> The --destination option doesn't exist.

## Question

What is the difference between the Interpreter and the JIT (Just-In-Time) compiler?<br><br>

Please select 1 option<br><br>

A) The Interpreter compiles the whole program before starting; the JIT does it during execution<br>
B) The Interpreter is used for .java files; the JIT is used for .class files<br>
C) There is no difference; they are two names for the same process<br>
D) The Interpreter reads bytecode line-by-line; the JIT compiles frequently used code into machine language

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

The <strong>Interpreter</strong> starts immediately by reading and executing bytecode instruction by instruction (fast startup, slow execution). The <strong>JIT</strong> identifies "hot" code (frequently executed) and compiles it into <strong>native machine code</strong> for maximum performance.<br><br>

<strong>A) is incorrect:</strong> Java doesn't compile the whole program to machine code before starting.<br>
<strong>B) is incorrect:</strong> Both work on bytecode (.class) during execution.<br>
<strong>C) is incorrect:</strong> They are distinct mechanisms working together in the JVM.

## Question

In Object-Oriented Programming (OOP), what is the primary purpose of Encapsulation?<br><br>

Please select 1 option<br><br>

A) To make the code run on any operating system<br>
B) To allow objects to inherit methods from a parent class<br>
C) To transform a class into an object in memory<br>
D) To protect data and ensure consistency by controlling access through rules

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

<strong>Encapsulation</strong> is about <strong>protecting data</strong> and controlling modifications. Instead of allowing direct access to variables, we use methods (like getters/setters) to apply business rules.<br><br>

<strong>A) is incorrect:</strong> That's the "Write Once Run Anywhere" principle.<br>
<strong>B) is incorrect:</strong> That is the definition of Inheritance.<br>
<strong>C) is incorrect:</strong> That is called Instantiation.

## Question

Which concept allows a single method call to have different behaviors depending on the actual object being used at runtime?<br><br>

Please select 1 option<br><br>

A) Encapsulation<br>
B) Compilation<br>
C) Build process<br>
D) Polymorphism

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

<strong>Polymorphism</strong> allows objects of different types to be treated as a common parent type, but execute their own specific behavior at <strong>runtime</strong>.<br><br>

Example: A <strong>Dog</strong> and a <strong>Cat</strong> both have a <code>makeSound()</code> method, but the result (Bark vs Meow) depends on the <strong>real object</strong>.<br><br>

<strong>A) is incorrect:</strong> Encapsulation is about data protection.<br>
<strong>B) and C) are incorrect:</strong> These are technical processes, not OOP principles.

## Question

What is the difference between "Compiling" and "Building" in Java?<br><br>

Please select 1 option<br><br>

A) Compiling is the overall process; Building is just javac<br>
B) They are exactly the same thing<br>
C) Compiling creates a JAR; Building creates a .class file<br>
D) Compiling is the .java to .class transformation; Building is the complete process including packaging

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

<strong>Compiling</strong> is the specific task of <strong>javac</strong> (.java → .class).<br>
<strong>Building</strong> is the <strong>global process</strong> (often managed by Maven, Gradle, or an IDE) that includes compiling, running tests, organizing files, and creating a JAR.<br><br>

<strong>A) and C) are reversed:</strong> javac is a part of the build, and the build produces the final JAR.

## Question

What does a JAR file typically contain?<br><br>

Please select 1 option<br><br>

A) The original .java source code files<br>
B) The javac compiler and the JRE<br>
C) The installation files for the JDK<br>
D) Compiled .class files, resources, and a MANIFEST file

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

A <strong>JAR (Java ARchive)</strong> is a package used to distribute applications. It contains <strong>bytecode</strong> (.class), not source code, along with images, configuration files, and metadata (MANIFEST.MF).<br><br>

<strong>A) is incorrect:</strong> We deliver bytecode, not source code.<br>
<strong>B) and C) are incorrect:</strong> Tools like javac or the JDK are installed on the machine, not inside the application's JAR.

## Question

Which environment is specifically dedicated to "functional validation" where business rules are verified before going live?<br><br>

Please select 1 option<br><br>

A) DEV (Development)<br>
B) PROD (Production)<br>
C) JVM (Virtual Machine)<br>
D) REC (Recette / UAT)

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

The <strong>REC (Recette)</strong> or <strong>UAT (User Acceptance Testing)</strong> environment is used to verify that the application meets the functional requirements before it reaches the end users.<br><br>

<strong>A) is incorrect:</strong> DEV is for writing and testing code by developers.<br>
<strong>B) is incorrect:</strong> PROD is for real users with real data.<br>
<strong>C) is incorrect:</strong> JVM is the technical execution environment, not a deployment stage.

## Question

What are "Program Arguments" in a Java application?<br><br>

Please select 1 option<br><br>

A) Configuration settings for the JVM memory (e.g., -Xmx)<br>
B) The source code written inside the main method<br>
C) The list of libraries imported in the class<br>
D) Values passed by the user to the application at launch (String[] args)

## Réponse

<strong>Réponse correcte :</strong> D)<br><br>

<strong>Program arguments</strong> are the values you provide when launching the program (e.g., <code>java Main value1 value2</code>). They are stored in the <strong>String[] args</strong> array of the <code>main</code> method.<br><br>

<strong>A) is incorrect:</strong> Those are <strong>JVM Arguments</strong> (used to configure the machine, not the program logic).